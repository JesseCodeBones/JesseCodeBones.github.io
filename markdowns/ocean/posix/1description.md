# 简介
### 文件描述符  
I/O 系统调用使用文件描述符—（往往是数值很小的）非负整数—来指代打开的文件。
获取文件描述符的常用手法是调用 open()，在参数中指定 I/O 操作目标文件的路径名。
通常，由 shell 启动的进程会继承 3 个已打开的文件描述符：描述符 0 为标准输入，指代为
进程提供输入的文件；描述符 1 为标准输出，指代供进程写入输出的文件；描述符 2 为标准
错误，指代供进程写入错误消息或异常通告的文件。在交互式 shell 或程序中，上述三者一般都
指向终端。在 stdio 函数库中，这几种描述符分别与文件流 stdin、stdout 和 stderr 相对应。  

### 进程的内存布局  
逻辑上将一个进程划分为以下几部分（也称为段）。
y 文本：程序的指令。
y数据：程序使用的静态变量。
y堆：程序可从该区域动态分配额外内存。
y栈：随函数调用

### 领起一个进程
更为常见的
情况是使用系统调用 execve()去加载并执行一个全新程序。execve()会销毁现有的文本段、数
据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。  
### 子进程 父进程
每一进程都有一个唯一的整数型进程标识符（PID）。此外，每一进程还具有一个父进程
标识符（PPID）属性，用以标识请求内核创建自己的进程。  

### 退出进程
终止一个进程：其一，进程可使用_exit()系统调用（或相关的
图第 2 章
异步社区会员 flyman150(2410757683@qq.com) 专享 尊重版权
基本概念
25exit()库函数）
，请求退出；其二，向进程传递信号，将其“杀死”
。无论以何种方式退出，进程
都会生成“终止状态”
，一个非负小整数，可供父进程的 wait()系统调用检测。

### 特权进程
在 UNIX 系统上，就传统意义而言，特权进程是指有效用户 ID 为 0（超级用户）的进程。通
常由内核所施加的权限限制对此类进程无效。与之相反，术语“无特权”
（或非特权）进程是指由
其他用户运行的进程。此类进程的有效用户 ID 为非 0 值，且必须遵守由内核所强加的权限规则。

### init进程
系统引导时，内核会创建一个名为 init 的特殊进程，即“所有进程之父”，该进程的相应
程序文件为/sbin/init。系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代
进程创建。init 进程的进程号总为 1，且总是以超级用户权限运行。谁（哪怕是超级用户）都
不能“杀死”init 进程，只有关闭系统才能终止该进程。init 的主要任务是创建并监控系统运
行所需的一系列进程。（手册页 init(8)中包含了 init 进程的详细信息。）

### 守护进程
守护进程指的是具有特殊用途的进程，系统创建和处理此类进程的方式与其他进程相同，
但以下特征是其所独有的：
y “长生不老”
。守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”
。
y
守护进程在后台运行，且无控制终端供其读取或写入数据。
守护进程中的例子有 syslogd（在系统日志中记录消息）和 httpd（利用 HTTP 分发 Web 页面）
。

### 打印environment
```C++
extern char ** environ;
int main() {
   for (environ; *environ; ++environ) {
        printf("%s\n", *environ);
    }
  return 0;
}
```
### 资源限制
每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用 setrlimit()，
进程可为自己消耗的各类资源设定一个上限。
### 内存映射
调用系统函数 mmap()的进程，会在其虚拟地址空间中创建一个新的内存映射。  
映射分为两类。  
y 文件映射：将文件的部分区域映射入调用进程的虚拟内存。映射一旦完成，对文件映射  
内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载。  
y 相映成趣的是并无文件与之相对应的匿名映射，其映射页面的内容会被初始化为 0。  
当两个或多个进程共享的页面相同时，进程之一对页面内容的改动是否为其他进程所见呢？这
取决于创建映射时所传入的标志参数。若传入标志为私有，则某进程对映射内容的修改对于其
他进程是不可见的，而且这些改动也不会真地落实到文件上；若传入标志为共享，对映射内容
的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。内存映射用途很多，其中
包括：以可执行文件的相应段来初始化进程的文本段、内存（内容填充为 0）分配、文件 I/O（即
映射内存 I/O）以及进程间通信（通过共享映射）
。

### 进程间通信方式
*  信号（signal），用来表示事件的发生。  
* 管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO，用于在进程间传递数据。  
* 套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。  
* 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以
锁定。  
* 消息队列，用于在进程间交换消息（数据包）。  
* 信号量（semaphore），用来同步进程动作。  
* 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容
时，其他所有进程会立即了解到这一变化。

### 会话、控制终端和控制进程
会话指的是一组进程组（任务）。会话中的所有进程都具有相同的会话标识符。会话首进
程（session leader）是指创建会话的进程，其进程 ID 会成为会话 ID。
使用会话最多的是支持任务控制的 shell，由 shell 创建的所有进程组与 shell 自身隶属于
同一会话，shell 是此会话的会话首进程。
通常，会话都会与某个控制终端相关。控制终端建立于会话首进程初次打开终端设备之时。
对于由交互式 shell 所创建的会话，这恰恰是用户的登录终端。一个终端至多只能成为一个会
话的控制终端 
打开控制终端会致使会话首进程成为终端的控制进程。一旦断开了与终端的连接（比如，
关闭了终端窗口），控制进程将会收到 SIGHUP 信号。
在任一时点，会话中总有一个前台进程组（前台任务），可以从终端中读取输入，向终
端发送输出。如果用户在控制终端中输入了“中断”
（通常是 Control-C）或“挂起”字符（通
常是 Control-Z），那么终端驱动程序会发送信号以终止或挂起（亦即停止）前台进程组。一
个会话可以拥有任意数量的后台进程组（后台任务），由以“&”字符结尾的行命令来创建。
支持任务控制的 shell 提供如下命令：列出所有任务，向任务发送信号，以及在前后台任
务之间来回切换。

